/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body (nRF24 receiver - SPI1, UART1)
 ******************************************************************************
 * NOTE:
 * - Wiring must be:
 *   PA5  -> SCK
 *   PA6  -> MISO
 *   PA7  -> MOSI
 *   PB12 -> CSN  (idles HIGH)
 *   PB13 -> CE   (idles LOW)
 *   VCC  -> 3.3V (use 3.3V only)
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <string.h>
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
#define CE_PORT   GPIOB
#define CE_PIN    GPIO_PIN_13

#define CSN_PORT  GPIOB
#define CSN_PIN   GPIO_PIN_12

#define CE_HIGH()  HAL_GPIO_WritePin(CE_PORT, CE_PIN, GPIO_PIN_SET)
#define CE_LOW()   HAL_GPIO_WritePin(CE_PORT, CE_PIN, GPIO_PIN_RESET)
#define CSN_HIGH() HAL_GPIO_WritePin(CSN_PORT, CSN_PIN, GPIO_PIN_SET)
#define CSN_LOW()  HAL_GPIO_WritePin(CSN_PORT, CSN_PIN, GPIO_PIN_RESET)

/* ---------- nRF24 commands & registers ---------- */
#define R_REGISTER        0x00
#define W_REGISTER        0x20
#define R_RX_PAYLOAD      0x61
#define FLUSH_RX          0xE2

#define REG_CONFIG        0x00
#define REG_RF_CH         0x05
#define REG_RF_SETUP      0x06
#define REG_STATUS        0x07
#define REG_RX_ADDR_P0    0x0A
#define REG_TX_ADDR       0x10
#define REG_RX_PW_P0      0x11

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
SPI_HandleTypeDef hspi1;
UART_HandleTypeDef huart1;

/* USER CODE BEGIN PV */
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_SPI1_Init(void);
static void MX_USART1_UART_Init(void);
/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* Simple UART print for debugging (TeraTerm on USART1) */
static void UART1_Print(const char *s) {
	HAL_UART_Transmit(&huart1, (uint8_t*) s, strlen(s), HAL_MAX_DELAY);
}

/* SPI register read/write helpers */
static uint8_t nrf_read_reg(uint8_t reg) {
	uint8_t cmd = R_REGISTER | (reg & 0x1F);
	uint8_t val = 0xFF;

	CSN_LOW();
	HAL_SPI_Transmit(&hspi1, &cmd, 1, HAL_MAX_DELAY);
	HAL_SPI_Receive(&hspi1, &val, 1, HAL_MAX_DELAY);
	CSN_HIGH();

	return val;
}

static void nrf_write_reg(uint8_t reg, uint8_t val) {
	uint8_t buf[2] = { (uint8_t) (W_REGISTER | (reg & 0x1F)), val };

	CSN_LOW();
	HAL_SPI_Transmit(&hspi1, buf, 2, HAL_MAX_DELAY);
	CSN_HIGH();
}

static void nrf_write_addr(uint8_t reg, const uint8_t *addr5) {
	uint8_t cmd = (uint8_t) (W_REGISTER | (reg & 0x1F));
	CSN_LOW();
	HAL_SPI_Transmit(&hspi1, &cmd, 1, HAL_MAX_DELAY);
	HAL_SPI_Transmit(&hspi1, (uint8_t*) addr5, 5, HAL_MAX_DELAY);
	CSN_HIGH();
}

/* Initialize nRF24 in RX mode (must match TX) */
static void nrf_init_rx(void) {
	/* Ensure idle states first */
	CE_LOW();
	CSN_HIGH();
	HAL_Delay(5);

	const uint8_t addr[5] = { 'R', 'X', 'A', 'A', 'A' }; /* must match TX */

	/* set pipe 0 RX addr and TX addr (TX addr often mirror) */
	nrf_write_addr(REG_RX_ADDR_P0, addr);
	nrf_write_addr(REG_TX_ADDR, addr);

	/* RF channel & setup - must match transmitter */
	nrf_write_reg(REG_RF_CH, 40); /* channel 40 */
	nrf_write_reg(REG_RF_SETUP, 0x06); /* 1Mbps, 0dBm */

	/* payload size for pipe0 - 32 bytes (sender should send <=32) */
	nrf_write_reg(REG_RX_PW_P0, 32);

	/* CONFIG: PWR_UP=1, PRIM_RX=1, CRC enabled (2 bytes) -> 0x0F */
	nrf_write_reg(REG_CONFIG, 0x0F);
	HAL_Delay(2);

	/* clear IRQ flags (write 1 to bits) */
	nrf_write_reg(REG_STATUS, 0x70);

	/* start listening */
	CE_HIGH();
	HAL_Delay(5);

	UART1_Print("NRF24 RX READY\r\n");
}

/* Read payload (32 bytes) */
static void nrf_read_payload(char *buf32) {
	uint8_t cmd = R_RX_PAYLOAD;
	CSN_LOW();
	HAL_SPI_Transmit(&hspi1, &cmd, 1, HAL_MAX_DELAY);
	HAL_SPI_Receive(&hspi1, (uint8_t*) buf32, 32, HAL_MAX_DELAY);
	CSN_HIGH();

	/* clear RX_DR bit in STATUS */
	nrf_write_reg(REG_STATUS, 0x40);
}

/* Optional: print some register values for debug */
static void NRF_Debug_Dump(void) {
	char t[128];
	uint8_t cfg = nrf_read_reg(REG_CONFIG);
	uint8_t ch = nrf_read_reg(REG_RF_CH);
	uint8_t rf = nrf_read_reg(REG_RF_SETUP);
	uint8_t st = nrf_read_reg(REG_STATUS);
	uint8_t pw = nrf_read_reg(REG_RX_PW_P0);
	snprintf(t, sizeof(t),
			"DEBUG: CFG=0x%02X CH=%d RFSET=0x%02X STATUS=0x%02X PW=%d\r\n", cfg,
			ch, rf, st, pw);
	UART1_Print(t);
}

/* Test SPI read/write */
static void NRF_SPI_Test(void) {
	UART1_Print("Testing SPI write/read...\r\n");
	nrf_write_reg(REG_RF_CH, 40);
	HAL_Delay(5);
	uint8_t ch = nrf_read_reg(REG_RF_CH);
	char msg[64];
	snprintf(msg, sizeof(msg), "RF_CH READBACK = %d\r\n", ch);
	UART1_Print(msg);
}

/* Main receiver poll loop - call frequently in while(1) */
static void NRF_Receiver_Loop(void) {
	uint8_t status = nrf_read_reg(REG_STATUS);

	if (status & 0x40) { /* RX_DR */
		char payload[33];
		memset(payload, 0, sizeof(payload));
		nrf_read_payload(payload);

		UART1_Print("RX -> ");
		UART1_Print(payload);
		UART1_Print("\r\n");
	}
}

/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {
	/* MCU init */
	HAL_Init();
	SystemClock_Config();

	/* Peripherals init */
	MX_GPIO_Init();
	MX_SPI1_Init();
	MX_USART1_UART_Init();

	/* Ensure CSN high, CE low before anything */
	CSN_HIGH();
	CE_LOW();
	HAL_Delay(5);

	UART1_Print("\r\n--- NRF RECEIVER START ---\r\n");

	/* Initialize nRF as RX and debug */
	nrf_init_rx();
	HAL_Delay(5);
	NRF_Debug_Dump();
	NRF_SPI_Test();

	/* Main loop: poll for incoming packets */
	while (1) {
		NRF_Receiver_Loop();
		HAL_Delay(2);
	}
}

/* SystemClock_Config, MX_SPI1_Init, MX_USART1_UART_Init, MX_GPIO_Init follow */
/* Keep these generated stubs but ensure GPIO init sets CSN=HIGH, CE=LOW initial state */
void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };

	/** Initializes the RCC Oscillators */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;

	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
	RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;  // default
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief SPI1 Initialization Function
 * @retval None
 */
void MX_SPI1_Init(void) {
	/* SPI1 configured as master, Mode0 (CPOL=0 CPHA=0), 8-bit */
	hspi1.Instance = SPI1;
	hspi1.Init.Mode = SPI_MODE_MASTER;
	hspi1.Init.Direction = SPI_DIRECTION_2LINES;
	hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi1.Init.CLKPolarity = SPI_POLARITY_LOW; /* CPOL = 0 */
	hspi1.Init.CLKPhase = SPI_PHASE_1EDGE; /* CPHA = 0 */
	hspi1.Init.NSS = SPI_NSS_SOFT;
	hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2; /* fastest - try lower if module is flaky */
	hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	if (HAL_SPI_Init(&hspi1) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief USART1 Initialization Function
 * @retval None
 */
void MX_USART1_UART_Init(void) {
	huart1.Instance = USART1;
	huart1.Init.BaudRate = 115200;
	huart1.Init.WordLength = UART_WORDLENGTH_8B;
	huart1.Init.StopBits = UART_STOPBITS_1;
	huart1.Init.Parity = UART_PARITY_NONE;
	huart1.Init.Mode = UART_MODE_TX_RX;
	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
	if (HAL_UART_Init(&huart1) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief GPIO Initialization Function
 *        Note: set CSN HIGH and CE LOW as idle states (important!)
 * @retval None
 */
void MX_GPIO_Init(void) {
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };

	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOD_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/* Configure PB12 (CSN) and PB13 (CE) as output push-pull */
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET); /* CSN = HIGH (idle) */
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET); /* CE  = LOW  (idle) */

	GPIO_InitStruct.Pin = GPIO_PIN_12 | GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/* Note: PA5/PA6/PA7 are SPI pins - if CubeMX generated them they will be configured elsewhere.
	 If not, ensure they are configured as:
	 PA5 -> AF push-pull (SPI1_SCK)
	 PA7 -> AF push-pull (SPI1_MOSI)
	 PA6 -> Input floating  (SPI1_MISO)
	 */
}

/* SystemClock_Config omitted here - keep your existing generated function unchanged */

/* Error_Handler (keep existing) */
void Error_Handler(void) {
	__disable_irq();
	while (1) {
	}
}

#ifdef  USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line)
{ }
#endif
